<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="@[toc] 【练习一 @理解通过 make 生成执行文件的过程】Solution：  操作系统镜像文件 ucore.img 是如何一步一步生成的？(需要比较详细地解释 Makefile 中每一条相关命令和命令参数的含义，以及说明命令导致的结果)  首先需要学习makefile的编写规则，可以简单看下 makefile入门遇到不懂的查GNU MAKE手册 链接: https:&#x2F;&#x2F;pan.baidu">
<meta property="og:type" content="article">
<meta property="og:title" content="uCore-lab1实验">
<meta property="og:url" content="http://example.com/2021/05/06/uCore-lab1%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="除魔">
<meta property="og:description" content="@[toc] 【练习一 @理解通过 make 生成执行文件的过程】Solution：  操作系统镜像文件 ucore.img 是如何一步一步生成的？(需要比较详细地解释 Makefile 中每一条相关命令和命令参数的含义，以及说明命令导致的结果)  首先需要学习makefile的编写规则，可以简单看下 makefile入门遇到不懂的查GNU MAKE手册 链接: https:&#x2F;&#x2F;pan.baidu">
<meta property="og:locale">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210114205616304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202101181612380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210118184441634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210118184506812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210119003636272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210119004017741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210119170316697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210124161758378.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210126002019350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210126180140110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210126224931696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210202155344578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2021-05-06T08:05:53.000Z">
<meta property="article:modified_time" content="2021-05-06T08:07:42.525Z">
<meta property="article:author" content="Qiming Zhai">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="rust">
<meta property="article:tag" content="X86">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210114205616304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://example.com/2021/05/06/uCore-lab1%E5%AE%9E%E9%AA%8C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'cn'
  };
</script>

  <title>uCore-lab1实验 | 除魔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">除魔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/uCore-lab1%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Qiming Zhai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="除魔">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          uCore-lab1实验
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-05-06 16:05:53 / Modified: 16:07:42" itemprop="dateCreated datePublished" datetime="2021-05-06T16:05:53+08:00">2021-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B8%85%E5%8D%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">清华操作系统课程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>20 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>@[toc]</p>
<h1 id="【练习一-理解通过-make-生成执行文件的过程】"><a href="#【练习一-理解通过-make-生成执行文件的过程】" class="headerlink" title="【练习一 @理解通过 make 生成执行文件的过程】"></a>【练习一 @理解通过 make 生成执行文件的过程】</h1><p><img src="https://img-blog.csdnimg.cn/20210114205616304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color=red><strong>Solution：</strong></font></p>
<ul>
<li>操作系统镜像文件 ucore.img 是如何一步一步生成的？(需要比较详细地解释 Makefile 中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</li>
</ul>
<p>首先需要学习makefile的编写规则，可以简单看下 <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7097.html">makefile入门</a><br>遇到不懂的查GNU MAKE手册 链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1_v0m_XPpsXamYGEPkFlJeA">https://pan.baidu.com/s/1_v0m_XPpsXamYGEPkFlJeA</a>  密码: wod9<br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/gcc-parameter-detail.html">GCC参数</a></p>
<p>大概了解makefile的规则之后直接从最关键的地方看起，不用太关注makefile的细节</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># create ucore.img</span></span><br><span class="line">UCOREIMG	:= $(call totarget,ucore.img)</span><br><span class="line"># 可以看到整个img由 bootloader和kernel组成 ，首先申请<span class="number">10000</span>字节的空间，然后将两者依次写入</span><br><span class="line">$(UCOREIMG): $(kernel) $(bootblock)</span><br><span class="line">	$(V)dd <span class="keyword">if</span>=/dev/zero of=$@ count=<span class="number">10000</span></span><br><span class="line">	$(V)dd <span class="keyword">if</span>=$(bootblock) of=$@ conv=notrunc</span><br><span class="line">	$(V)dd <span class="keyword">if</span>=$(kernel) of=$@ seek=<span class="number">1</span> conv=notrunc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create bootblock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历boot下的所有文件并且编译出 .o target文件</span></span><br><span class="line">bootfiles = $(call listf_cc,boot)</span><br><span class="line">$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bootblock = $(call totarget,bootblock)</span><br><span class="line">$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)</span><br><span class="line">	@<span class="built_in">echo</span> + ld <span class="variable">$@</span></span><br><span class="line">	<span class="comment"># 将目标文件 $^ 链接起来，同时指定代码段开始地址 为 0x7c00</span></span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)</span><br><span class="line">	<span class="comment"># 反汇编 查看目标文件或者可执行的目标文件的构成 C语言与汇编语言同时显示</span></span><br><span class="line">	@$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock)</span><br><span class="line">	<span class="comment"># objcopy把一种目标文件中的内容复制到另一种类型的目标文件中.</span></span><br><span class="line">	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)</span><br><span class="line">	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</span><br><span class="line"></span><br><span class="line">$(call create_target,bootblock)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># create kernel target</span></span><br><span class="line">KOBJS	= $(call read_packet,kernel libs)</span><br><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"><span class="comment"># kernel下的 编译 链接 </span></span><br><span class="line">$(kernel): tools/kernel.ld</span><br><span class="line"></span><br><span class="line">$(kernel): $(KOBJS)</span><br><span class="line">	@<span class="built_in">echo</span> + ld <span class="variable">$@</span></span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o <span class="variable">$@</span> $(KOBJS)</span><br><span class="line">	@$(OBJDUMP) -S <span class="variable">$@</span> &gt; $(call asmfile,kernel)</span><br><span class="line">	@$(OBJDUMP) -t <span class="variable">$@</span> | $(SED) <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27;</span> &gt; $(call symfile,kernel)</span><br><span class="line"></span><br><span class="line">$(call create_target,kernel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>  一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？<br>参考自wiki：**<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">主引导记录</a>**（Master Boot Record，缩写：MBR），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。在深入讨论主引导扇区内部结构的时候，有时也将其开头的446字节内容特指为“主引导记录”（MBR），其后是4个16字节的“磁盘分区表”（DPT），以及2字节的结束标志（55AA）。因此，在使用“主引导记录”（MBR）这个术语的时候，需要根据具体情况判断其到底是指整个主引导扇区，还是主引导扇区的前446字节。</p>
</li>
<li><p><strong>启动代码</strong><br>主引导记录最开头是第一阶段引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。</p>
</li>
<li><p><strong>主引导扇区的加载过程</strong></p>
<ul>
<li>BIOS加电（台湾用语：引导）自检（Power On Self Test – POST）。BIOS执行内存地址为FFFF:0000H处的跳转指令，跳转到固化在ROM中的自检程序处，对系统硬件（包括内存）进行检查。</li>
</ul>
<ul>
<li><p>读取主引导记录（MBR）。当BIOS检查到硬件正常并与CMOS中的设置相符后，按照CMOS中对启动设备的设置顺序检测可用的启动设备。BIOS将相应启动设备的第一个扇区（也就是MBR扇区）读入内存地址为0000:7C00H处。</p>
</li>
<li><p>检查0000:7DFEH-0000:7DFFH（MBR的结束标志位）是否等于55AAH，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示”NO ROM BASIC”然后死机。</p>
</li>
<li><p>当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备。启动设备的MBR将自己复制到0000:0600H处，然后继续执行。</p>
<p>  事实上，BIOS不仅检查0000:7DFEH-0000:7DFFH（MBR的结束标志位）是否等于55AAH，往往还对磁盘是否有写保护、主引导扇区中是否存在活动分区等进行检查。如果发现磁盘有写保护，则显示磁盘写保护出错信息；如果发现磁盘中不存在活动分区，则显示类似如下的信息“Remove disk or other media Press any key to restart”。</p>
</li>
</ul>
</li>
<li><p><strong>硬盘分区表</strong></p>
<p>硬盘分区表占据主引导扇区的64个字节（偏移01BEH–偏移01FDH），可以对四个分区的信息进行描述，其中每个分区的信息占据16个字节。具体每个字节的定义可以参见硬盘分区结构信息。下面是一个例子：</p>
<p>如果某一分区在硬盘分区表的信息如下： 80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00<br><img src="https://img-blog.csdnimg.cn/202101181612380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>则我们可以看到，最前面的”80”是一个分区的激活标志，表示系统可引导[1]；”01 01 00”表示分区开始的磁头号为1，开始的扇区号为1，开始的柱面号为0；”0B”表示分区的系统类型是FAT32，其他比较常用的有04（FAT16）、07（NTFS）；”FE BF FC”表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764；”3F 00 00 00”表示首扇区的相对扇区号为63（小端序）；”7E 86 BB 00”表示总扇区数为12289662（小端序）。</p>
<p>对于大于8.4G的现代硬盘，CHS已经无法表示，BIOS使用LBA模式，对于超出的部分，CHS值通常设为0xFEFFFF，并加以忽略，直接使用Offset 0x08-0x0c的4字节相对值，再进行内部转换。</p>
</li>
<li><p><strong>结束标志字</strong><br>结束标志字55，AA（偏移1FEH－偏移1FFH）最后两个字节，是检验主引导记录是否有效的标志。</p>
</li>
</ul>
<h1 id="【练习二-使用-qemu-执行并调试-lab1-中的软件】"><a href="#【练习二-使用-qemu-执行并调试-lab1-中的软件】" class="headerlink" title="【练习二 @使用 qemu 执行并调试 lab1 中的软件】"></a>【练习二 @使用 qemu 执行并调试 lab1 中的软件】</h1><p><img src="https://img-blog.csdnimg.cn/20210118184441634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210118184506812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color=red><strong>Solution：</strong></font></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://learningos.github.io/ucore_os_webdocs/lab0/lab0_2_4_2_1_qemu_runtime_arguments.html">【qemu参数】</a>通过qemu加载img，并且在cpu执行第一条指令之前停止<br>qemu-system-i386  -S -s -hda bin/ucore.img -monitor stdio<br>这时qemu会呆住<br><img src="https://img-blog.csdnimg.cn/20210119003636272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>【<a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/display-instruction-pc.html">一百个gdb使用技巧</a>】启动gdb，加载调试table，链接远程</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(base) ╭─work ~/os_kernel_lab/labcodes/lab1  ‹master*› </span><br><span class="line">╰─➤  i386-elf-gdb</span><br><span class="line">GNU gdb (GDB) 8.3</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;--host=x86_64-apple-darwin19.0.0 --target=i386-elf&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>.</span><br><span class="line">/Users/zhaiqiming/.gdbinit:1: Error <span class="keyword">in</span> sourced <span class="built_in">command</span> file:</span><br><span class="line">No symbol table is loaded.  Use the <span class="string">&quot;file&quot;</span> <span class="built_in">command</span>.</span><br><span class="line"><span class="comment">#加一个7c00处的断点，BIOS会把启动设备的第一个扇区（也就是MBR扇区）读入内存地址为0000:7C00H处</span></span><br><span class="line">(gdb) b *0x7c00  </span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line"><span class="comment">#读入调试符号表</span></span><br><span class="line">(gdb) file bin/kernel</span><br><span class="line">Reading symbols from bin/kernel...</span><br><span class="line"><span class="comment">#链接远程qemu</span></span><br><span class="line">(gdb) target remote :1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line">0x0000fff0 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment">#查看cs寄存器</span></span><br><span class="line">(gdb) x/i <span class="variable">$cs</span></span><br><span class="line">   0xf000:      add    %al,(%eax)</span><br><span class="line"><span class="comment">#查看ip寄存器</span></span><br><span class="line">(gdb) x/i <span class="variable">$eip</span></span><br><span class="line">=&gt; 0xfff0:      add    %al,(%eax)</span><br><span class="line"><span class="comment">#通过cs：ip得到第一条指令的地址，查看发现是跳转指令，也就是说会长跳转到BIOS指令开始的地方执行</span></span><br><span class="line">(gdb) x/2i 0xffff0</span><br><span class="line">   0xffff0:     ljmp   <span class="variable">$0x3630</span>,<span class="variable">$0xf000e05b</span></span><br><span class="line">   0xffff7:     das    </span><br><span class="line"><span class="comment">#继续，在7c00处停止，此时bios结束，进入系统引导部分，qemu动起来</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 1, 0x00007c00 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210119004017741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="【练习三-分析-bootloader-进入保护模式的过程】"><a href="#【练习三-分析-bootloader-进入保护模式的过程】" class="headerlink" title="【练习三 @分析 bootloader 进入保护模式的过程】"></a>【练习三 @分析 bootloader 进入保护模式的过程】</h1><p><img src="https://img-blog.csdnimg.cn/20210119170316697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color=red><strong>Solution：</strong></font></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://learningos.github.io/ucore_os_webdocs/lab1/lab1_3_1_bios_booting.html">BIOS启动过程</a><br>BIOS 实际上是被固化在计算机 ROM（只读存储器）芯片上的一个特殊的软件，为上层软件提供最底层的、最直接的硬件控制与支持。更形象地说，BIOS 就是 PC 计算机硬件与上层软件程序之间的一个”桥梁”，负责访问和控制硬件。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://learningos.github.io/ucore_os_webdocs/lab1/lab1_3_2_1_protection_mode.html">保护模式与分段机制</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://learningos.github.io/ucore_os_webdocs/lab1/lab1_appendix_a20.html">为何 &amp; 如何开启A20</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/orlion/p/5765339.html">att汇编伪指令</a><br> 汇编程序中以”.”开头的名称不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊的指示，称为汇编指示或伪操作。</p>
<ul>
<li>.section指示把代码划分成若干个段(section)，程序被操作系统加载时，每个段被加载到不同的地址，具有不同的读写执行权限。</li>
<li>.data段保存程序的数据是可读写的，C程序的全局变量也属于.data段。上边的程序没定义数据所以.data是空的。</li>
<li>.text段保存代码，是只读和可执行的，后面那些指令都属于这个.text段。</li>
<li>.globl  _start<br>_start是一个符号(Symbol)，符号在汇编程序中代表一个地址，可以用在指令中，汇编程序经过汇编器的处理后所有的符号都被替换成它所代表的地址值。在C中我们可以通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数其实就是调转到该函数的第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。</li>
<li>.globl<br>指示告诉汇编器_start这个符号要被链接器用到，所以要在目标文件的符号表中给它特殊标记。_start就像C程序的main函数一样特殊是整个程序的入口，链接器在链接时会查找目标文件中的_start符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个_start符号并且用.globl声明。如果一个符号没有用.globl指示声明这个符号就不会被链接器用到。</li>
<li>_start:<br>_start在这里就像C语言的语句标号一样。汇编器在处理汇编程序时会计算每个数据对象和每条指令的地址，当汇编器看到这样一个标号时，就把它下面一条指令的地址作为_start这个符号所代表的地址。而_start这个符号又比较特殊事整个程序的入口地址,所以下一条指令movl $1, %eax就成了程序中第一条被执行的指令。</li>
</ul>
</li>
<li><p>分析Bootasm.S来看ucore是如何完成以上三点的</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;asm.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the CPU: switch to 32-bit protected mode, jump into C.</span></span><br><span class="line"><span class="comment"># The BIOS loads this code from the first sector of the hard disk into</span></span><br><span class="line"><span class="comment"># memory at physical address 0x7c00 and starts executing in real mode</span></span><br><span class="line"><span class="comment"># with %cs=0 %ip=7c00.</span></span><br><span class="line"><span class="comment"># 开启CPU -&gt; 切换到保护模式 -&gt; 跳转到C语言代码去执行</span></span><br><span class="line"><span class="comment"># BIOS会从硬盘的第一个扇区加载Bootasm.S</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相当于C++的define 用来定义常量</span></span><br><span class="line">.<span class="built_in">set</span> PROT_MODE_CSEG,        0x8                     <span class="comment"># 内核代码段选择子 kernel code segment selector</span></span><br><span class="line">.<span class="built_in">set</span> PROT_MODE_DSEG,        0x10                    <span class="comment"># 内核数据段选择子 kernel data segment selector</span></span><br><span class="line">.<span class="built_in">set</span> CR0_PE_ON,             0x1                     <span class="comment"># CR0的第PE位置为1 protected mode enable flag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span></span><br><span class="line"><span class="comment"># 这个开始的位置在系统启动的时候会被加载到7c00,是运行bootloader时的入口</span></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                                             <span class="comment"># 设置汇编的目标为16-bit模式 Assemble for 16-bit mode</span></span><br><span class="line">    cli                                             <span class="comment"># 屏蔽中断 Disable interrupts</span></span><br><span class="line">    cld                                             <span class="comment"># 将 DF 标志清零 String operations increment</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set up the important data segment registers (DS, ES, SS).</span></span><br><span class="line">    <span class="comment"># 设置各个数据段寄存器的值</span></span><br><span class="line">    xorw %ax, %ax                                   <span class="comment"># Segment number zero</span></span><br><span class="line">    movw %ax, %ds                                   <span class="comment"># -&gt; DS : Data Segment</span></span><br><span class="line">    movw %ax, %es                                   <span class="comment"># -&gt; ES : Extra Segment</span></span><br><span class="line">    movw %ax, %ss                                   <span class="comment"># -&gt; SS : Stack Segment</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Enable A20:</span></span><br><span class="line">    <span class="comment">#  For backwards compatibility with the earliest PCs, physical</span></span><br><span class="line">    <span class="comment">#  address line 20 is tied low, so that addresses higher than</span></span><br><span class="line">    <span class="comment">#  1MB wrap around to zero by default. This code undoes this.</span></span><br><span class="line">seta20.1:</span><br><span class="line">	<span class="comment">#循环检测0x64端口，第二位标志inputBuffer是否为空</span></span><br><span class="line">    inb <span class="variable">$0x64</span>, %al                                  <span class="comment"># Wait for not busy(8042 input buffer empty).</span></span><br><span class="line">    testb <span class="variable">$0x2</span>, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line">	<span class="comment">#向64端口发送写命令 0d1h </span></span><br><span class="line">    movb <span class="variable">$0xd1</span>, %al                                 <span class="comment"># 0xd1 -&gt; port 0x64</span></span><br><span class="line">    outb %al, <span class="variable">$0x64</span>                                 <span class="comment"># 0xd1 means: write data to 8042&#x27;s P2 port</span></span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">	<span class="comment">#循环检测0x64端口，第二位标志inputBuffer是否为空</span></span><br><span class="line">    inb <span class="variable">$0x64</span>, %al                                  <span class="comment"># Wait for not busy(8042 input buffer empty).</span></span><br><span class="line">    testb <span class="variable">$0x2</span>, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line">	<span class="comment">#向 60h 写入 Output Port 的数据，保证第二位为 1</span></span><br><span class="line">    movb <span class="variable">$0xdf</span>, %al                                 <span class="comment"># 0xdf -&gt; port 0x60</span></span><br><span class="line">    outb %al, <span class="variable">$0x60</span>                                 <span class="comment"># 0xdf = 11011111, means set P2&#x27;s A20 bit(the 1 bit) to 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Switch from real to protected mode, using a bootstrap GDT</span></span><br><span class="line">    <span class="comment"># and segment translation that makes virtual addresses</span></span><br><span class="line">    <span class="comment"># identical to physical addresses, so that the</span></span><br><span class="line">    <span class="comment"># effective memory map does not change during the switch.</span></span><br><span class="line">    <span class="comment"># 使用引导GDT和段转换使虚拟地址与物理地址相同，从而在实模式切换到保护模式的过程中，有效内存映射在切换期间不会更改</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#gdtdes是一个段，lgdt命令是load gdt，加载全局描述符表</span></span><br><span class="line">    lgdt gdtdesc </span><br><span class="line">    <span class="comment">#cr0的 PE 位置为1代表开启保护模式</span></span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl <span class="variable">$CR0_PE_ON</span>, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Jump to next instruction, but in 32-bit code segment.</span></span><br><span class="line">    <span class="comment"># Switches processor into 32-bit mode.</span></span><br><span class="line">    <span class="comment"># 跳转到第一条32-bit的指令出开始执行 ; 至此开始进入保护模式</span></span><br><span class="line">    <span class="comment"># ljmp $section,$offset即跳转到section:offset地址,改变cs寄存器</span></span><br><span class="line">    ljmp <span class="variable">$PROT_MODE_CSEG</span>, <span class="variable">$protcseg</span></span><br><span class="line"></span><br><span class="line">.code32                                             <span class="comment"># 设置汇编的目标为32-bit模式 Assemble for 32-bit mode</span></span><br><span class="line">protcseg:</span><br><span class="line">    <span class="comment"># Set up the protected-mode data segment registers</span></span><br><span class="line">    <span class="comment"># 设置各个数据段寄存器的值</span></span><br><span class="line">    movw <span class="variable">$PROT_MODE_DSEG</span>, %ax                       <span class="comment"># Our data segment selector</span></span><br><span class="line">    movw %ax, %ds                                   <span class="comment"># -&gt; DS: Data Segment</span></span><br><span class="line">    movw %ax, %es                                   <span class="comment"># -&gt; ES: Extra Segment</span></span><br><span class="line">    movw %ax, %fs                                   <span class="comment"># -&gt; FS</span></span><br><span class="line">    movw %ax, %gs                                   <span class="comment"># -&gt; GS</span></span><br><span class="line">    movw %ax, %ss                                   <span class="comment"># -&gt; SS: Stack Segment</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span></span><br><span class="line">    <span class="comment"># 设置栈寄存器,因为栈地址空间是自高向低拓展的,所以当前栈的可用范围就是0--start(0x7c00) ; 设置完成后进入C函数bootmain</span></span><br><span class="line">    movl <span class="variable">$0x0</span>, %ebp</span><br><span class="line">    movl <span class="variable">$start</span>, %esp</span><br><span class="line">    call bootmain</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If bootmain returns (it shouldn&#x27;t), loop.</span></span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bootstrap GDT</span></span><br><span class="line">.p2align 2                                          <span class="comment"># force 4 byte alignment</span></span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     <span class="comment"># null seg</span></span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           <span class="comment"># code seg for bootloader and kernel</span></span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 <span class="comment"># data seg for bootloader and kernel</span></span><br><span class="line"><span class="comment"># 段表格式</span></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word 0x17                                      <span class="comment"># sizeof(gdt) - 1</span></span><br><span class="line">    .long gdt                                       <span class="comment"># address gdt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="【练习四-分析-bootloader-加载-ELF-格式的-OS-的过程】"><a href="#【练习四-分析-bootloader-加载-ELF-格式的-OS-的过程】" class="headerlink" title="【练习四 @分析 bootloader 加载 ELF 格式的 OS 的过程】"></a>【练习四 @分析 bootloader 加载 ELF 格式的 OS 的过程】</h1><p><img src="https://img-blog.csdnimg.cn/20210124161758378.png" alt="在这里插入图片描述"><br><font color=red><strong>Solution：</strong></font></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://learningos.github.io/ucore_os_webdocs/lab1/lab1_3_2_3_dist_accessing.html">硬盘访问概述</a></li>
<li><a target="_blank" rel="noopener" href="https://learningos.github.io/ucore_os_webdocs/lab1/lab1_3_2_4_elf.html">ELF文件格式概述</a></li>
<li>bootmain.c<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *********************************************************************</span></span><br><span class="line"><span class="comment"> * This a dirt simple boot loader, whose sole job is to boot</span></span><br><span class="line"><span class="comment"> * an ELF kernel image from the first IDE hard disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DISK LAYOUT</span></span><br><span class="line"><span class="comment"> *  * This program(bootasm.S and bootmain.c) is the bootloader.</span></span><br><span class="line"><span class="comment"> *    It should be stored in the first sector of the disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The 2nd sector onward holds the kernel image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The kernel image must be in ELF format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BOOT UP STEPS</span></span><br><span class="line"><span class="comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span></span><br><span class="line"><span class="comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span></span><br><span class="line"><span class="comment"> *    into memory and jumps to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * Assuming this boot loader is stored in the first sector of the</span></span><br><span class="line"><span class="comment"> *    hard-drive, this code takes over...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * control starts in bootasm.S -- which sets up protected mode,</span></span><br><span class="line"><span class="comment"> *    and a stack so C code then run, then calls bootmain()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE        512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR          ((struct elfhdr *)0x10000)      <span class="comment">// scratch space</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* waitdisk - wait for disk ready */</span></span><br><span class="line"><span class="comment">/* 检查io 端口 0x1F7的状态, 第7位为0则硬盘不忙 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">waitdisk</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">inb</span>(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* readsect - read a single sector at @secno into @dst */</span></span><br><span class="line"><span class="comment">/* 从secno扇区读取数据到dst */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">readsect</span>(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno) &#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    <span class="built_in">waitdisk</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0x1F2 到 0x1F6是写入LBA命令的参数, 0x1F7是写入命令的类型, 0x20代表从磁盘读入命令*/</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x1F2</span>, <span class="number">1</span>);                         <span class="comment">// count = 1</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    <span class="built_in">waitdisk</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    <span class="comment">/* 每次读入4字节, 所以需要重复128次*/</span></span><br><span class="line">    <span class="built_in">insl</span>(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span></span><br><span class="line"><span class="comment"> * might copy more than asked.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">/* 包装一下 可以读取任意长度的内容 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">readseg</span>(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    <span class="comment">/* 要读入的位置也要能整除扇区大小 */</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="comment">/* 计算offset属于哪个扇区,从哪个扇区开始读 ,加1因为0扇区被引导占用,ELF文件从1扇区开始*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        <span class="built_in">readsect</span>((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bootmain - the entry of bootloader */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">bootmain</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// read the 1st page off disk</span></span><br><span class="line">    <span class="comment">/* 页大小为4k ,读入了 512 * 8 个字节 ELF头*/</span></span><br><span class="line">    <span class="built_in">readseg</span>((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a valid ELF?</span></span><br><span class="line">    <span class="comment">/* 判断是否为合法 ELF文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">    <span class="comment">/* 从ELF头中获取各个部分应该加载到的位置,ph是起点指针,ELFHDR-&gt;e_phnum是各个部分的数量*/</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        <span class="built_in">readseg</span>(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">    <span class="comment">// note: does not return</span></span><br><span class="line">    <span class="comment">/* 进入内核 */</span></span><br><span class="line">    ((<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    <span class="built_in">outw</span>(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    <span class="built_in">outw</span>(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="【练习五-实现函数调用堆栈跟踪函数】"><a href="#【练习五-实现函数调用堆栈跟踪函数】" class="headerlink" title="【练习五 @实现函数调用堆栈跟踪函数】"></a>【练习五 @实现函数调用堆栈跟踪函数】</h1><p><img src="https://img-blog.csdnimg.cn/20210126002019350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color=red><strong>Solution：</strong></font></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://learningos.github.io/ucore_os_webdocs/lab1/lab1_2_1_5_ex5.html">栈寄存器与栈空间</a><br>BP是函数栈空间的栈底，SP则一直是栈顶，所有函数调用过程中都会反复记录BP，目的是记录调用函数的栈空间<br>ip代表了当前要执行的指令的地址,显然在函数调用完成后执行的肯定是调用结束后的代码,所以减一就代表函数的入口了 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>) &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp(), eip = read_eip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i ++) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);</span><br><span class="line">        <span class="keyword">uint32_t</span> *args = (<span class="keyword">uint32_t</span> *)ebp + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;0x%08x &quot;</span>, args[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        print_debuginfo(eip - <span class="number">1</span>);<span class="comment">//eip - 1 代表当前指令的位置</span></span><br><span class="line">        eip = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">1</span>]; </span><br><span class="line">        ebp = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="【练习六-完善中断初始化和处理】"><a href="#【练习六-完善中断初始化和处理】" class="headerlink" title="【练习六 @完善中断初始化和处理】"></a>【练习六 @完善中断初始化和处理】</h1><img src="https://img-blog.csdnimg.cn/20210126180140110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color=red><strong>Solution：</strong></font></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/143002272">操作系统特权级</a></li>
<li>通过下图可以看到三种gate 表项的结构,其中选择子和偏移就代表了中断例程的入口<br><img src="https://img-blog.csdnimg.cn/20210126224931696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* segment descriptors 一个表项的描述如下*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_lim_15_0 : <span class="number">16</span>;        <span class="comment">// low bits of segment limit</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_base_15_0 : <span class="number">16</span>;        <span class="comment">// low bits of segment base address</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_base_23_16 : <span class="number">8</span>;        <span class="comment">// middle bits of segment base address</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_type : <span class="number">4</span>;            <span class="comment">// segment type (see STS_ constants)</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_s : <span class="number">1</span>;                <span class="comment">// 0 = system, 1 = application</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_dpl : <span class="number">2</span>;            <span class="comment">// descriptor Privilege Level</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_p : <span class="number">1</span>;                <span class="comment">// present</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_lim_19_16 : <span class="number">4</span>;        <span class="comment">// high bits of segment limit</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_avl : <span class="number">1</span>;            <span class="comment">// unused (available for software use)</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_rsv1 : <span class="number">1</span>;            <span class="comment">// reserved</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_db : <span class="number">1</span>;                <span class="comment">// 0 = 16-bit segment, 1 = 32-bit segment</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_g : <span class="number">1</span>;                <span class="comment">// granularity: limit scaled by 4K when set</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_base_31_24 : <span class="number">8</span>;        <span class="comment">// high bits of segment base address</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>要填写idt_init函数,首先需要查看的就是使用到的SETGATE宏 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Set up a normal interrupt/trap gate descriptor</span></span><br><span class="line"><span class="comment"> *   - istrap: 1 trap, 0中断</span></span><br><span class="line"><span class="comment"> *   - sel: Code segment selector for interrupt/trap handler 代码段选择子</span></span><br><span class="line"><span class="comment"> *   - off: Offset in code segment for interrupt/trap handler 代码段内偏移</span></span><br><span class="line"><span class="comment"> *   - dpl: Descriptor Privilege Level - the privilege level required DPL特权级(代码段静态特权级)</span></span><br><span class="line"><span class="comment"> *          for software to invoke this interrupt/trap gate explicitly</span></span><br><span class="line"><span class="comment"> *          using an int instruction.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) &#123;            \</span></span><br><span class="line">    (gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>)(off) &amp; <span class="number">0xffff</span>;        \</span><br><span class="line">    (gate).gd_ss = (sel);                                \</span><br><span class="line">    (gate).gd_args = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_rsv1 = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span><br><span class="line">    (gate).gd_s = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_dpl = (dpl);                                \</span><br><span class="line">    (gate).gd_p = <span class="number">1</span>;                                    \</span><br><span class="line">    (gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>)(off) &gt;&gt; <span class="number">16</span>;        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 其他的预定义宏在memlayout.h中 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* global segment number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_KTEXT    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_KDATA    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_UTEXT    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_UDATA    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_TSS        5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* global descriptor numbers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_KTEXT    ((SEG_KTEXT) &lt;&lt; 3)        <span class="comment">// kernel text</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_KDATA    ((SEG_KDATA) &lt;&lt; 3)        <span class="comment">// kernel data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_UTEXT    ((SEG_UTEXT) &lt;&lt; 3)        <span class="comment">// user text</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_UDATA    ((SEG_UDATA) &lt;&lt; 3)        <span class="comment">// user data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_TSS        ((SEG_TSS) &lt;&lt; 3)        <span class="comment">// task segment selector</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DPL_KERNEL    (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DPL_USER    (3)</span></span><br></pre></td></tr></table></figure>
 idt_init()的实现 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Interrupt descriptor table:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Must be built at run time because shifted function addresses can&#x27;t</span></span><br><span class="line"><span class="comment"> * be represented in relocation records.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">idt</span>[256] =</span> &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">idt_pd</span> =</span> &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)idt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */</span></span><br><span class="line"><span class="comment">// 建立中断描述符表，并使能中断</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">idt_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 2 */</span></span><br><span class="line">     <span class="comment">/* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)? @每个中断服务例程的入口地址在哪里?</span></span><br><span class="line"><span class="comment">      *     All ISR&#x27;s entry addrs are stored in __vectors.  @都存储在 __vectors 里</span></span><br><span class="line"><span class="comment">      *     where is uintptr_t __vectors[] ? @那么 __vectors 的存储地址在哪里?</span></span><br><span class="line"><span class="comment">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c @__vectors[] 定义在 kern/trap/vector.S 中,是由tools/vector.c生成的</span></span><br><span class="line"><span class="comment">      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR) @</span></span><br><span class="line"><span class="comment">      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.</span></span><br><span class="line"><span class="comment">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT). @现在需要设置IDT中的各个例程的入口</span></span><br><span class="line"><span class="comment">      *     Can you see idt[256] in this file? Yes, it&#x27;s IDT! you can use SETGATE macro to setup each item of IDT @通过使用SETGATE</span></span><br><span class="line"><span class="comment">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using &#x27;lidt&#x27; instruction. @将IDT的地址加载到中断寄存器中 使能中断</span></span><br><span class="line"><span class="comment">      *     You don&#x27;t know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span></span><br><span class="line"><span class="comment">      *     Notice: the argument of lidt is idt_pd. try to find it!</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[]; <span class="comment">// 通过extern去寻找 __vectors这个符号</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//内核中的中断全部初始化为 DPL_KERNEL 特权级 , 系统调用初始化为 DPL_USER 特权级</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc); i++)&#123;</span><br><span class="line">            SETGATE(idt[i],<span class="number">0</span>,GD_KTEXT,__vectors[i],DPL_KERNEL); </span><br><span class="line">            <span class="comment">// idt[i] : 待初始化idt段</span></span><br><span class="line">            <span class="comment">// 0 : 初始化为中断而不是trap</span></span><br><span class="line">            <span class="comment">// GD_KTEXT : 等于 (SEG_KTEXT) &lt;&lt; 3 ，是处理中断的代码段编号</span></span><br><span class="line">            <span class="comment">// __vectors[i] : 存的是第 i 个位置的地址 , 也就是代码段内偏移的值 , 并且每个处理例程都会跳转到 __alltraps处 , __alltraps段内会call trap ,这样就进入了C 语言函数trap() 处理中断</span></span><br><span class="line">            <span class="comment">// DPL_KERNEL : 中断的特权级为 DPL_KERNEL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义 切换到内核态的系统调用 </span></span><br><span class="line">    SETGATE(idt[T_SWITCH_TOK], <span class="number">1</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">    <span class="comment">//使能中断</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>每一百个时钟中断打印一次 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* trap_dispatch - dispatch based on what type of trap occurred */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        <span class="comment">/* LAB1 YOUR CODE : STEP 3 */</span></span><br><span class="line">        <span class="comment">/* handle the timer interrupt */</span></span><br><span class="line">        <span class="comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c</span></span><br><span class="line"><span class="comment">         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span></span><br><span class="line"><span class="comment">         * (3) Too Simple? Yes, I think so!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ticks++;</span><br><span class="line">        <span class="keyword">if</span>(ticks % TICK_NUM == <span class="number">0</span>)&#123;</span><br><span class="line">            print_ticks();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_COM1:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;serial [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.</span></span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">        panic(<span class="string">&quot;T_SWITCH_** ??\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE1:</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE2:</span><br><span class="line">        <span class="comment">/* do nothing */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// in kernel, it must be a mistake</span></span><br><span class="line">        <span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            panic(<span class="string">&quot;unexpected trap in kernel.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="【练习七-实现用户态和内核态的切换】"><a href="#【练习七-实现用户态和内核态的切换】" class="headerlink" title="【练习七 @实现用户态和内核态的切换】"></a>【练习七 @实现用户态和内核态的切换】</h1><img src="https://img-blog.csdnimg.cn/20210202155344578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYWlxaW1pbmcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p>challenge1 要求实现用户态和内核态的切换,通过systemCall的方式实现,在调用端使用int触发软中断(T_SWITCH_TOK,T_SWITCH_TOU)</p>
<p>首先要理解用户态和内核态的切换的终极目标是什么.个人理解<br>U2K: 把当前栈切换到内核栈,当前运行特权级切换为0<br>K2U: 把当前栈切换到用户栈,当前运行特权级切换为用户级别</p>
<p>首先看下K2U的调用端:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lab1_switch_to_user(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 : TODO</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="comment">/* 答案中提到: </span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">		在lab1_switch_to_user中，调用T_SWITCH_TOU中断。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">		注意从中断返回时，会多pop两位，并用这两位的值更新ss,sp，损坏堆栈。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">		所以要先把栈压两位，并在从中断返回后修复esp。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">		   </span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">		这个的原因: 因为在U2K的时候因为发生了运行栈的切换,就硬件来说，执行iret时存在两种情况，一是栈上保存的CS的权限级别（内核态或用户态）与当前一致，不考虑ss和esp；二是栈上保存的权限级别与当前不同，需要恢复ss和esp。OS的任务，是利用iret的功能，在修改CS的同时不改动其它寄存器的值。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">		但是在trapentry.S的代码中没有做相关处理,所以在调用端做了一下兼容.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">		*/</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;sub $0x8, %%esp \n&quot;</span>    </span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="comment">/* [int 命令的执行过程](https://blog.csdn.net/Sagittarius_Warrior/article/details/53128613) */</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="comment">/*  [Lab1 Challenge1中关于 mov %ebp, %esp 意义的讨论](https://piazza.com/class/i5j09fnsl7k5x0?cid=1468) */</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp&quot;</span>  </span></span></span><br><span class="line"><span class="function"><span class="params">	    : </span></span></span><br><span class="line"><span class="function"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOU)</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾一下中断的处理流程: 中断一个硬件调用软件的过程 , 每当收到一条中断的时候,首先会根据中断号查找提前设置好的idt,然后根据选择子查询ldt,获得代码执行入口,接下来执行时会跳转到统一处理的入口__alltraps,  __alltraps首先会将各种参数进行压栈保存现场,然后构造调用 void trap(struct trapframe *tf) 时的参数,然后 pushl %esp 相当于进行一个传参操作(供后面调整栈段时), 然后就进入了C函数处理中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"># 中断处理</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memlayout.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># vectors.S sends all traps here.</span></span><br><span class="line">.text</span><br><span class="line">.globl __alltraps</span><br><span class="line">__alltraps:</span><br><span class="line">    # ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span><br><span class="line">    # 将寄存器压栈来构造 trapframe 结构体(在 trap.h 中, 已经 __attribute__((packed)) 取消了gcc的内存对齐)</span><br><span class="line">    # 本代码段中可以看到,首先压的是 ds ,这说明其他的寄存器的压栈是由硬件完成的</span><br><span class="line">    <span class="meta"># therefore make the stack look like a struct trapframe</span></span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line"></span><br><span class="line">    <span class="meta"># pushal : 保存通用寄存器中的上下文环境</span></span><br><span class="line">    # 在pushal指令中各寄存器的入栈顺序分别为： </span><br><span class="line">    # %eax-&gt;%ecx-&gt;%edx-&gt;%ebx-&gt;%esp-&gt;%ebp-&gt;%esi-&gt;%edi </span><br><span class="line">    # 总共占用<span class="number">4</span>*<span class="number">8</span>=<span class="number">32</span>字节 </span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # 组装完结构体之后,将参数的地址压栈,作为trap()函数的参数</span><br><span class="line">    pushl %esp</span><br><span class="line">    # ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span><br><span class="line"></span><br><span class="line">    # 设置内核的数据段,中断例程都是运行在内核态</span><br><span class="line">    movl $GD_KDATA, %eax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    # 调用 trap(tf) , tf的值等于 esp 寄存器里的值</span><br><span class="line">    <span class="meta"># call trap 相当于以下两条指令</span></span><br><span class="line">    <span class="meta"># pushl %eip</span></span><br><span class="line">    <span class="meta"># movl trap, %eip</span></span><br><span class="line">    call trap</span><br><span class="line"></span><br><span class="line">    <span class="meta"># pop the pushed stack pointer</span></span><br><span class="line">    # 从之前将 esp 压栈的位置取出地址的值, 相当于恢复现场, </span><br><span class="line">    # 但是里面的内容已经变了(切换到了新的trapframe开始执行,取决于是TOK还是TOU)</span><br><span class="line">    popl %esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 恢复手动压栈的那些寄存器, 屏蔽trap number 和 error code </span><br><span class="line"># 恢复是从中断处理例程里新建的trapframe中取值的,所以这就完成了切换</span><br><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    <span class="meta"># restore registers from stack</span></span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    <span class="meta"># restore %ds, %es, %fs and %gs</span></span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    <span class="meta"># get rid of the trap number and <span class="meta-keyword">error</span> code</span></span><br><span class="line">    # 这里相当于跳过了结构体的两个成员</span><br><span class="line">    addl $<span class="number">0x8</span>, %esp</span><br><span class="line"></span><br><span class="line">    <span class="meta"># iret指令 : https:<span class="comment">//baike.baidu.com/item/iret/1314268?fr=aladdin</span></span></span><br><span class="line">    <span class="meta"># iret会按照 ip -&gt; cs -&gt; psw -&gt; esp -&gt; ss 的顺序进行恢复</span></span><br><span class="line">    # 可以看到这个顺序与 trapframe 结构体成员内存布局一致, 也就是从新的trapframe中完成了恢复现场</span><br><span class="line">    # 总结下来, 整个过程就是进入中断,通过软硬结合来保存现场,然后修改寄存器(完成TOU,TOK切换),然后在新位置恢复现场(#^.^#)</span><br><span class="line">    # 切换时的处理见例程代码</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体切换的实现</span></span><br><span class="line">   <span class="comment">//LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.</span></span><br><span class="line">   <span class="comment">/*  </span></span><br><span class="line"><span class="comment">       修改出一个新的trapframe,并且将返回地址设置为此新trapframe,通过这样的方式完成寄存器的修改</span></span><br><span class="line"><span class="comment">       切换到用户态需要修改 sp , 因为发起中断时是在内核态, 所以没有特权级的变换, 不会有保存的 ss 和 sp</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">       <span class="keyword">if</span> (tf-&gt;tf_cs != USER_CS) &#123;</span><br><span class="line">           switchk2u = *tf;</span><br><span class="line">           switchk2u.tf_cs = USER_CS;</span><br><span class="line">           switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;</span><br><span class="line">           switchk2u.tf_esp = (<span class="keyword">uint32_t</span>)tf + <span class="keyword">sizeof</span>(struct trapframe)<span class="number">-16</span>;</span><br><span class="line">	</span><br><span class="line">           <span class="comment">// set eflags, make sure ucore can use io under user mode.</span></span><br><span class="line">           <span class="comment">// if CPL &gt; IOPL, then cpu will generate a general protection.</span></span><br><span class="line">           switchk2u.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">	</span><br><span class="line">           <span class="comment">// set temporary stack</span></span><br><span class="line">           <span class="comment">// then iret will jump to the right stack</span></span><br><span class="line">           *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)&amp;switchk2u;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">       因为中断处理时,已经在内核栈了,只要滑动一下esp就行,不用改ss</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">       <span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">           tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">           tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">           tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">           switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (<span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>));</span><br><span class="line">           memmove(switchu2k, tf, <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>);</span><br><span class="line">           *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)switchu2k;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
              <a href="/tags/rust/" rel="tag"># rust</a>
              <a href="/tags/X86/" rel="tag"># X86</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/06/THU-OS-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B-uCore-Schedule/" rel="prev" title="THU-OS-清华大学操作系统课程(uCore)-Schedule">
      <i class="fa fa-chevron-left"></i> THU-OS-清华大学操作系统课程(uCore)-Schedule
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%90%E7%BB%83%E4%B9%A0%E4%B8%80-%E7%90%86%E8%A7%A3%E9%80%9A%E8%BF%87-make-%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%91"><span class="nav-number">1.</span> <span class="nav-text">【练习一 @理解通过 make 生成执行文件的过程】</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%90%E7%BB%83%E4%B9%A0%E4%BA%8C-%E4%BD%BF%E7%94%A8-qemu-%E6%89%A7%E8%A1%8C%E5%B9%B6%E8%B0%83%E8%AF%95-lab1-%E4%B8%AD%E7%9A%84%E8%BD%AF%E4%BB%B6%E3%80%91"><span class="nav-number">2.</span> <span class="nav-text">【练习二 @使用 qemu 执行并调试 lab1 中的软件】</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%90%E7%BB%83%E4%B9%A0%E4%B8%89-%E5%88%86%E6%9E%90-bootloader-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%91"><span class="nav-number">3.</span> <span class="nav-text">【练习三 @分析 bootloader 进入保护模式的过程】</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%90%E7%BB%83%E4%B9%A0%E5%9B%9B-%E5%88%86%E6%9E%90-bootloader-%E5%8A%A0%E8%BD%BD-ELF-%E6%A0%BC%E5%BC%8F%E7%9A%84-OS-%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%91"><span class="nav-number">4.</span> <span class="nav-text">【练习四 @分析 bootloader 加载 ELF 格式的 OS 的过程】</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%90%E7%BB%83%E4%B9%A0%E4%BA%94-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0%E3%80%91"><span class="nav-number">5.</span> <span class="nav-text">【练习五 @实现函数调用堆栈跟踪函数】</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%90%E7%BB%83%E4%B9%A0%E5%85%AD-%E5%AE%8C%E5%96%84%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A4%84%E7%90%86%E3%80%91"><span class="nav-number">6.</span> <span class="nav-text">【练习六 @完善中断初始化和处理】</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%90%E7%BB%83%E4%B9%A0%E4%B8%83-%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%E3%80%91"><span class="nav-number">7.</span> <span class="nav-text">【练习七 @实现用户态和内核态的切换】</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qiming Zhai"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Qiming Zhai</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaiqiming" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaiqiming" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zhaiqimingac@outlook.com" title="E-Mail → zhaiqimingac@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qiming Zhai</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">28k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">26 mins.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
